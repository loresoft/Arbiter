---
title: Identifiers Query
description: Query to retrieve multiple entities identified by a collection of keys
---

# Identifiers Query

The `EntityIdentifiersQuery<TKey, TReadModel>` represents a query to retrieve multiple entities identified by a collection of keys. This query follows the CQRS (Command Query Responsibility Segregation) pattern and returns a collection of read models representing the requested entities.

## Overview

The identifiers query is a fundamental part of the Arbiter framework's bulk query operations. It inherits from `CacheableQueryBase<IReadOnlyCollection<TReadModel>>` which provides automatic security context, caching support, and JSON serialization.

```csharp
public record EntityIdentifiersQuery<TKey, TReadModel> : CacheableQueryBase<IReadOnlyCollection<TReadModel>>
```

## Key Features

- **Security Context**: Built-in `ClaimsPrincipal` support for authentication and authorization
- **Audit Tracking**: Automatic tracking of who activated the query and when
- **Cache Integration**: Built-in caching support with hash-based cache keys for identifier collections
- **Validation**: Integrated with validation pipeline behaviors
- **Mapping**: Uses Mapper for converting between entities and read models
- **Tenant Support**: Optional multi-tenant support through pipeline behaviors
- **Null Safety**: Validates that the identifiers collection is not null at construction time
- **Bulk Operations**: Efficiently retrieves multiple entities in a single database operation

## Type Parameters

| Parameter    | Description                                                    |
| ------------ | -------------------------------------------------------------- |
| `TKey`       | The type of the keys used to identify the entities             |
| `TReadModel` | The type of the read model returned as the result of the query |

## Constructor Parameters

| Parameter   | Type                        | Description                                                                      |
| ----------- | --------------------------- | -------------------------------------------------------------------------------- |
| `principal` | `ClaimsPrincipal?`          | The user's security context. Used for audit tracking and authorization           |
| `ids`       | `IReadOnlyCollection<TKey>` | The collection of identifiers for the entities to retrieve (guaranteed non-null) |

## Properties

| Property | Type                        | Description                                                |
| -------- | --------------------------- | ---------------------------------------------------------- |
| `Ids`    | `IReadOnlyCollection<TKey>` | The collection of identifiers for the entities to retrieve |

## Caching Features

The identifiers query automatically implements caching capabilities with hash-based cache keys:

### Cache Key Generation

```csharp
public override string GetCacheKey()
{
    var hash = new HashCode();
    
    foreach (var id in Ids)
        hash.Add(id);
    
    return CacheTagger.GetKey<TReadModel, int>(CacheTagger.Buckets.Identifiers, hash.ToHashCode());
}
```

The cache key is generated by hashing all the identifiers in the collection, ensuring that queries with the same set of IDs (regardless of order) can share cached results.

### Cache Tag Support

```csharp
public override string? GetCacheTag()
    => CacheTagger.GetTag<TReadModel>();
```

Cache tags enable efficient cache invalidation when related entities are modified.

## Handler Implementations

The Arbiter framework provides built-in handlers for different data access patterns:

### Entity Framework Handler

```csharp
EntityIdentifiersQueryHandler<TContext, TEntity, TKey, TReadModel>
```

### MongoDB Handler

```csharp
EntityIdentifiersQueryHandler<TRepository, TEntity, TKey, TReadModel>
```

## Service Registration

Register identifiers query support using the provided extension methods:

### Entity Framework

```csharp
services.AddEntityQueries<MyDbContext, Product, int, ProductReadModel>();
```

### MongoDB

```csharp
services.AddEntityQueries<IProductRepository, Product, int, ProductReadModel>();
```

## Model Mapping with IMapper

The identifiers query relies on `IMapper<TSource, TDestination>` to convert between entities and read models:

### Entity Framework Mapping

```csharp
var projected = Mapper.ProjectTo<TEntity, TReadModel>(query);
return await projected.ToListAsync(cancellationToken);
```

### MongoDB Mapping

```csharp
return Mapper.Map<IList<TEntity>, IReadOnlyCollection<TReadModel>>(results);
```

## Pipeline Behaviors

The identifiers query automatically includes several pipeline behaviors:

- **Tenant Security**: `TenantAuthenticateQueryBehavior` (if read model implements `IHaveTenant<TKey>`)
  - Validates that the user has access to the specified tenant
  - Ensures tenant isolation for multi-tenant applications

- **Soft Delete Filtering**: `DeletedFilterQueryBehavior` (if read model implements `ITrackDeleted`)
  - Automatically filters out soft-deleted entities from query results
  - Respects the `IsDeleted` flag on entities

- **Caching**: `MemoryCacheQueryBehavior` or `HybridCacheQueryBehavior`
  - Automatically caches query results based on the hash-based cache key
  - Respects cache expiration policies set on the query
  - Handles cache invalidation using cache tags

## Cache Configuration

Configure caching policies on your queries:

### Sliding Expiration

```csharp
var ids = new List<int> { 1, 2, 3, 4, 5 };
var query = new EntityIdentifiersQuery<int, ProductReadModel>(principal, ids);
query.Cache(TimeSpan.FromMinutes(15)); // 15-minute sliding expiration

var result = await mediator.Send(query);
```

### Absolute Expiration

```csharp
var ids = new List<int> { 1, 2, 3, 4, 5 };
var query = new EntityIdentifiersQuery<int, ProductReadModel>(principal, ids);
query.Cache(DateTimeOffset.UtcNow.AddHours(1)); // Expires at specific time

var result = await mediator.Send(query);
```

### Memory Cache Registration

```csharp
services.AddEntityMemoryCache();
```

### Hybrid Cache Registration

```csharp
services.AddEntityHybridCache();
```

## Usage Examples

### Basic Usage

```csharp
var principal = new ClaimsPrincipal(new ClaimsIdentity([new(ClaimTypes.Name, "JohnDoe")]));
var ids = new List<int> { 1, 2, 3, 4, 5 };
var query = new EntityIdentifiersQuery<int, ProductReadModel>(principal, ids);

var result = await mediator.Send(query);
Console.WriteLine($"Retrieved {result?.Count} products.");
```

### In ASP.NET Core Controller

```csharp
[HttpPost("bulk")]
public async Task<IReadOnlyCollection<ProductReadModel>> GetProducts([FromBody] IReadOnlyCollection<int> ids)
{
    var query = new EntityIdentifiersQuery<int, ProductReadModel>(User, ids);
    return await mediator.Send(query) ?? new List<ProductReadModel>();
}
```

### In Minimal API Endpoint

```csharp
app.MapPost("/products/bulk", async (
    [FromServices] IMediator mediator,
    [FromBody] IReadOnlyCollection<int> ids,
    ClaimsPrincipal user) =>
{
    var query = new EntityIdentifiersQuery<int, ProductReadModel>(user, ids);
    var result = await mediator.Send(query);
    return Results.Ok(result ?? new List<ProductReadModel>());
});
```

### With Caching

```csharp
var ids = new List<int> { 1, 2, 3, 4, 5 };
var query = new EntityIdentifiersQuery<int, ProductReadModel>(principal, ids);

// Configure 30-minute sliding cache
query.Cache(TimeSpan.FromMinutes(30));

var result = await mediator.Send(query);
```

## Return Values

- **Success**: Returns `IReadOnlyCollection<TReadModel>` containing the found entities
- **Partial Results**: Returns only the entities that exist (missing IDs are not included in results)
- **Empty Collection**: Returns empty collection if no entities are found
- **Exception**: Throws appropriate exceptions for validation or data access errors

## Error Handling

The query handlers include built-in error handling and will throw appropriate exceptions:

- **`ArgumentNullException`**: When the ids parameter is null
- **`DomainException`**: For business rule violations
- **Database exceptions**: For data access errors
- **Authorization exceptions**: When user lacks access to entities

## Best Practices

1. **Batch Size Considerations**: For very large ID collections (>1000), consider batching queries
2. **Cache Appropriately**: Use caching for frequently accessed entity sets with reasonable expiration times
3. **Security**: Always pass the current user's `ClaimsPrincipal` for proper authorization
4. **Key Types**: Use appropriate key types (`int`, `Guid`, `string`) based on your domain
5. **Collection Types**: Use `IReadOnlyCollection<TKey>` or `List<TKey>` for the identifiers parameter
6. **Mapping Configuration**: Configure efficient mapping between entities and read models
7. **Result Handling**: Remember that results may contain fewer items than requested IDs if some entities don't exist
8. **Tenant Isolation**: Implement `IHaveTenant<TKey>` on read models for multi-tenant scenarios

## Performance Considerations

1. **Entity Framework**:
   - Uses `Contains` operator which translates to `IN` clause in SQL
   - Uses `ProjectTo` for efficient database projection
   - Applies `AsNoTracking()` for read-only operations

2. **MongoDB**:
   - Uses `HashSet<TKey>` for efficient `Contains` operations
   - Uses `AsQueryable()` for LINQ translation

3. **Caching**:
   - Hash-based cache keys ensure consistent caching regardless of ID order
   - Implement appropriate cache expiration to balance performance and data freshness

4. **Database Optimization**:
   - Ensure proper database indexes on identifier columns
   - Consider the impact of large `IN` clauses on database performance
   - Monitor query performance for large identifier collections

5. **Memory Usage**:
   - Be mindful of memory usage when processing large collections
   - Consider streaming or pagination for very large result sets
